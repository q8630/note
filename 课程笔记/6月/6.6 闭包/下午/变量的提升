1、变量提升
 js 代码执行的时候 ，浏览器会给你的js 代码执行提供一个全局作用域环境
    1、变量提升
    2、代码自上而下执行




   var  定义的变量  只提升变量名  不提示变量存储的值
   function  定义的函数 不仅提升函数名 ，还提升函数值

  1、只对变量等号左边的进行提升
  2、在条件判断下  不管是否满足条件 ，都要进行变量提升
     函数提升的时候  在es6 块级作用域，在块里面全部提升
     到全局下，只提升函数名 不提升函数值

  3、重名问题的处理
     遇到重名变量，后面直接覆盖前面的



2、es 6
  let 定义的变量 不存在 变量提升  但是存在语法检测
                 和window 不存在映射
                 在相同的作用域下 不能重复声明 但是变量的值可以修改


  暂时性死区（TDZ）
  未定义而使用 变量
   检测不到变量

   const 定义常量  （ 变量里面存储的值不能进行修改） 需要修改数值可给 数值的地址 重新赋值










堆栈内存的释放
   垃圾回收机制（浏览器的自主行为） 针对堆内存
    计数销毁（标记清除） ie 浏览器
    null  销毁 （引用计数） 其他浏览器


堆内存的释放
   堆内存存储的是引用数据类型

     如果把存储堆内存的变量设为 null  那么浏览器空闲的时候会自动的
     进行内存销毁

栈内存的释放
     栈内存中存储的是基本数据类型  代码的执行

     1、js 代码执行  会开辟一个栈内存 浏览器为其开辟一个全局作用域
     当浏览器关闭   全局作用域环境销毁
     2、函数执行的时候  会开辟一个栈内存 会形成私有作用域
        大多数情况下  函数一旦执行完  立即被销毁
        但是有些情况，函数执行完，函数内部的私有变量被函数外部所占用
        此时函数执行形成的私有作用域就不能被销毁  一旦被销毁，外部变量存储的值就没有了。
