1、普通对象
var obj={};
var obj=new Object();

对象的增删改查  对象解构赋值

查: obj.name  obj['name']



2、 json 对象

 json 是一种传输的数据格式
 json 严格要求，所有的属性必须加引号
 var obj={'name' :1, 'age':2};

 1、json的解析
json 解析为json格式的字符串  JSON.stringify()

json格式的字符串解析为json格式的对象 JSON.parse()
！注意 属性必须要用双引号包含，否则会抛出异常



 2、json的拷贝
简单的拷贝


浅拷贝



深拷贝


面向对象 ：在js中 万物皆对象
继承（原型）  封装（函数）  多态

对象：万物皆对象   Object（基类） 基层对象 ，所有的对象/类都是基于onject衍生的


类  ：Object（基类） 基层对象 ，所有的对象/类都是基于onject衍生的



实例 ： 真实存在的个体

js 中的类： Object  Array  Function Number
   HTMLCllection

   三句话，特点
   原型对象上面存放的是这个类的公共方法/属性

   所以的函数都天生自带一个属性prototype(原型 对象)
   所有的对象都天生自带一个_proto_（原型）属性
   所以的实例都通过_proto_属性  指向所属类的原型对象


   对象
  1、单例模式 命名空间  给每一个变量都开辟一个堆内存
   保证命名不冲突

   每一个命名空间都是对象Obejct类的一个单独实例=>单例模式

   var 233={  命名空间
   }

  2、高级单例模式 （ 项目中使用的模式） ：（利用单例模式和闭包的原理）
  var render = (function(){
  function fn1(){}
  function fn2(){}
  function fn3(){}
  return {
      fn2:fn2
      fn3:fn3
      }

  })()

   引申：模块化开发思想
  一个职能的模块，由一个团队负责
  一个模块 - 一个团队负责

  闭包会形成一个不销毁的私有作用域 ： 内存泄漏（内存溢出）、非常耗性能、


  工厂模式：
   三步骤： 原料、加工、出厂 （很少使用）


  构造函数模式 this


  构造函数具有两重角色： 既可以当作“普通函数”调用，也可以当作“类” 使用
  普通函数执行原理： 1形成一个私有栈内存，2形参赋值 ，3变量提升，4函数自上而下执行，5堆栈内存释放

  构造函数执行原理：
  1、同普通函数执行一样，形成一个私有的作用域（栈内存）
  私有变量（ 形参赋值、变量提升）
  2、构造函数执行独有的： 在js 代码自上而下执行前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不储存任何东西），
  并且让函数中的执行主体（this） 指向这个新的堆内存（this=== 创建的对象）
  3、代码自上而下执行
  4、【独有】代码完成，把之前创建的堆内存地址返回（浏览器默认返回）



  Person不仅是函数名 还是类名

this 指向person类 创建的实例



  原型模式 （结合构造函数）e
  每一个函数都天生自带一个属性 prototype（原型对象）
  prototype这个原型对象 ，又天生自带一个属性 constructor（构造器）
  每一个对象又天生自带一个属性 _proto_
  （实例是对象）

  原型：prototype （原型对象）：用来存放类的公有方法属性

  原型链： 实例想要调用某一个方法的时候，先找自己私有的，如果私有的内存空间中没有，那么它会通过_proto_
  往所属类的原型上查找，如果原型上也没有，它会通过_proto_一直往上查找，如果找不到直到Object 基类上为止。
  如果还是找不到，返回Undefined/或者报错

  我们把这种通过_proto_一直往上查找的机制称作“原型链”。
  作用域链： 变量的查找
  原型链： 原型对象上公共方法的查找


 原型重定向 ： （我们自己修改了原来默认的prototype 指向的内存 ）之后没有constructor属性，
 需要自己手动添加

 原型、原型链、原型重定向；
   可以定义/扩展自己的类
   可以把内置类的基础上扩展方法
   可以把公共方法放在原型上，供别人使用
   可以书写自己的原型方法

   内置类的原型，不能重定向 但是可以在原基础上扩展
   自定义的类，可以重定向



1、函数是三种角色 （普通函数、类、对象）
function fn(){}

fn()
普通函数


new fn()
构造函数

fn.add()
fn 当作一个对象


【this指向】
1、总结this 指向
  在自执行函数里  this=>window
  在构造函数中 this =>实例
  谁执行函数 this 就指向谁
  事件 ，谁执行这个事件 this 指向谁
  在回调函数中 this 指向window
  在箭头函数中的 this 一般指向上下文this （宿主环境）
      箭头函数中 不可以强制改变

 2、this 指向的改变
 第一个参数是用来改变this的
 强制改变this 指向的
    call（第一个参数是用来改变this的，后面的参数就是执行的实参）：立即执行

    apply（第一个参数是用来改变this的，第二个参数是一个数组（数组里面是实参的集合）） ：立即执行
    bind（第一个参数是用来改变this的，预修改this 指向）  ：预修改 最后执行，需要手动执行


    new (把this改变成 实例的this)
    第一次执行强制改变call   第二次把call 改变成this 指向的值

 arguments 和 this 只有函数才有，是函数的内置类

类的继承（通过原型、原型链实现继承 ）

原型继承

call 继承 是私有属性的继承

寄生组合式继承




3、对象上面的方法
 instanceof: 检测某一个实例是否隶属于这个类

 in
 in ：检测一个对象，不论这个对象是私有的/公有的，只要存在结果就是 true

toString  ：具体检测出这个隶属于那个类，
（只有对象上toString 可以检测出js 中划分的类）

constructor

hasOwnProPerty :检测当前对象是否为对象的私有属性





正则
js 的盒模型属性
放大镜效果
滑动轮播图
鼠标跟随效果
图片加载
瀑布流

js事件
事件池
事件委托
事件传播

bom
cookie
localstorage
sessiontrorage

